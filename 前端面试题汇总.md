# 前端面试题汇总

## HTML & CSS
1. 简述一下你对HTML语义化的理解？
   1. 用正确的标签做正确的事情。
   1. html语义化让页面的内容结构化，结构更清晰，便于对浏览器、搜索引擎解析;
   1. 即使在没有样式CSS情况下也以一种文档格式显示，并且是容易阅读的;
   1. 搜索引擎的爬虫也依赖于HTML标记来确定上下文和各个关键字的权重，利于seo;
   1. 使阅读源代码的人对网站更容易将网站分块，便于阅读维护理解。
   
1. 内联元素有哪些？块级元素有哪些？ 空(void)元素有那些？
   - 内联元素：  
     meta, a, i, span, em, b, strong, time, br, img, svg, label, input, textarea, select, button, script 等
   - 块级元素：  
     header, footer, aside, article, section, div, p, ol, ul, li, table, form, h1-h6, hr, canvas, audio, video, pre, blockquote, dl, dd 等
   - 空元素：  
     没有内容的 HTML 元素被称为空元素。
     br, hr, img, link
     
1. 行内元素/块级元素/空元素的分类是根据什么原理分的？  
   行内元素不会以新行开始，而块级元素会新起一行。没有内容的 HTML 元素被称为空元素。
   > 一般情况下，行内元素只能包含数据和其他行内元素。而块级元素可以包含行内元素和其他块级元素。
                                                                                  >
1. 介绍一下标准的CSS的盒子模型？低版本IE的盒子模型有什么不同的？  
   `标准盒子模型`：宽度 = 内容的宽度（content）+ border + padding + margin  
   `低版本IE盒子模型`：宽度 = 内容宽度（content+border+padding）+ margin
   
1. CSS选择器有哪些？哪些属性可以继承？并且阐明浏览器是如何解析CSS选择器的？如何写出高效的选择器？
   1. CSS选择器
      1. id选择器（ # myid）
      2. 类选择器（.myclassname）
      3. 标签选择器（div, h1, p）
      4. 相邻选择器（h1 + p）
      5. 子选择器（ul > li）
      6. 后代选择器（li a）
      7. 通配符选择器（ * ）
      8. 属性选择器（a\[rel = “external”]）
      9. 伪类选择器（a: hover, li: nth – child）
   1. 可继承的样式  
      font-size, font-family, color, cursor, line-height, list-style, text-align, text-indent, text-shadow
   1. 不何继承的样式  
      border, padding, margin, width, height
   
1. CSS优先级算法如何计算？
   1. 权值
      - 内联样式表的权值最高 1000；
      - ID 选择器的权值为 100
      - Class 类选择器的权值为 10
      - HTML 标签选择器的权值为 1
   1. 优先级算法
      是由四个级别和各个级别出现的次数决定的，值从左到右，左面的最大，一级大于一级。
      - 每个规则对应一个初始四位数：0,0,0,0
      - 若是ID选择符，则分别加0,1,0,0
      - 若是类选择符，属性选择符，伪类选择符，则分别加0,0,1,0
      - 若是元素选择器，伪类选择器，则分别加0,0,0,1
   1. 优先级高低
      - !important的优先级是最高的，但出现冲突时则需比较”四位数“
      - 优先级相同时，则采用就近原则
      - 继承得来的属性，其优先级最低
   1. 实例
      ```css
      body div p{color: green;}  --Specificity值为0,0,0,3
      div # sjweb { font-size:12px;}  --Specificity值为 0,1,0,1
      html > body div [id=”totals”] ul li > p {color:red;}  --Specificity值为 0,0,1,6
      ```
      
1. css的position属性有哪些取值，它们的行为是什么？  
   position属性分别有：
   - `static`: 默认值，没有定位，正常的文档流
   - `relative` 相对定位，正常的文档流，可用z-index层叠顺序
   - `absolute` 绝对定位，相对于 static 定位以外的第一个父元素进行定位，可用z-index层叠顺序
   - `fixed` 绝对定位，相对于浏览器窗口进行定位，可用z-index层叠顺序

## Javascript
1. JS有哪些数据类型？各数据类型在内存中的体现形式是什么样的？
   - JS的数据类型包括  
     1. 原始类型（基本数据类型）  
        Number，String，Boolean，null，undefined
     1. 对象类型（引用数据类型）
        Object，Array，Function, Data
   - 原始类型和对象类型的区别  
     1. `基本数据类型`是按值访问的，因为可以直接操作保存在变量中的实际值。
     1. `引用数据类型`是保存在堆内存中的对象。与其他语言的不同是，你不可以直接访问堆内存空间中的位置和操作堆内存空间。只能操作对象在栈内存中的引用地址。所以，**引用类型数据在栈内存中保存的实际上是对象在堆内存中的引用地址。**
     
1. 数据去重怎么实现？
   ```javascript
   function arraySet (arr) {
     return Array.from(new Set(arr))
   }
   
   console.log(arraySet([1, 2, 3, 1, 2, 3, 3]))     // [ 1, 2, 3 ]
   ```
   
1. 什么是对象或数组的浅拷贝和深拷贝？对象或数组的深拷贝如何实现？  
   假设B复制了A，当A变化时，如果B也变化，则为浅拷贝，如果B不变，则为深拷贝。
   
   数组深拷贝：  
   ES2015实现方法
   ```javascript
   const a = [1, 2, 3]
   const b = a.slice()
   a.push(4)
   console.log(a) // [ 1, 2, 3, 4 ]
   console.log(b) // [ 1, 2, 3 ]
    ```
    
    ES6实现方法
   ```javascript
   const a = [1, 2, 3]
   const b = [...a]
   a.push(4)
   console.log(a) // [ 1, 2, 3, 4 ]
   console.log(b) // [ 1, 2, 3 ]
    ```
   
1. Javascript有哪些内置对象？
   1. Number
   1. String
   1. Boolean
   1. Date
   1. Array
   1. Math
   1. Function
   1. RegExp
   
1. 解释下 JavaScript 中 `this` 是如何工作的？  
   `this` 永远指向函数运行时所在的对象，而不是函数被创建时所在的对象。匿名函数或不处于任何对象中的函数指向 window
    1. 如果是call，apply,with，指定的`this`是谁，就是谁
    1. 普通的函数调用，函数被谁直接调用，`this`就是谁
    1. 在事件中，`this`指向触发这个事件的对象，特殊的是，IE中的attachEvent中的`this`总是指向全局对象Window
    1. 在 HTML 事件句柄中，`this` 指向了接收事件的 HTML 元素
    
1. 描述一下变量的区别： null、undefined、undeclared  
   - null是空值
   - undefined是未定义
   - undeclared是在严格模式下没有声明变量所导致的错误
   
1. 表达式中，逻辑与和逻辑或的优先级哪个高？  
    逻辑与
   
1. 代码在严格模式和非严格模式下执行有什么区别？
    1. 在严格模式下不支持使用『arguments.callee/arguments.callee.caller』
    1. 在严格模式下arguments和形参没有映射机制
    1. 在严格模式下不允许给一个对象设置重复属性名，如：{ n: 10, n: 20 }
    1. 函数执行在严格模式下，如果没有明确指定执行的主体，this指向undefined，代表没有执行主体；在非严格模式下，如果没有明确指定执行主体，this指向window
    
1. `var a = 'abc'` 和 `var a = new String('abc')` 是一样吗？为什么？  
   不一样。首先，var a = 'abc'是声明一个简单值（原始值），而 var a = new String('abc')是声明一个复杂值。复杂值是通过引用进行存储和操作的，创建一个包含复杂对象的变量时，其值是内存中的一个引用地址，因此当验证 a === b（假设第二种声明是b） 时为false。其次，他们创建的类型一个是string型、另一个是object型，用instanceof来检验，a instanceof String为false，b instanceof String为true。
   
1. map与forEach的区别？  
   二者基本一致，map会返回遍历后的新数组，而forEach不会。
   
1. prototype如何实现继承？
   ```js
    function Person () {
      this.eyes = true
    }
    
    function American () {
      this.eyesColor = 'green'
    }
    
    American.prototype = new Person()
    
    let a = new American()
    console.log(a.eyes) // true 实现访问父级构造函数属性
    console.log(a.constructor === Person) // true
    console.log(a.__proto__.constructor === Person) // true
    console.log(a.__proto__ === American.prototype) // true
    console.log(American.prototype.constructor === Person) // true
    
    let p = new Person()
    console.log(p.constructor.prototype === p.__proto__) // true
    ```
   
1. 箭头函数与普通函数的区别
   1. 箭头函数不能用作构造函数，会报`Uncaught TypeError: B is not a constructor`
   1. 箭头函数不绑定arguments，会报`ReferenceError: arguments is not defined`，取而代之用rest参数…解决
   1. 箭头函数会捕获其所在上下文的 this 值，作为自己的 this 值
   1. 箭头函数当方法使用的时候没有定义this绑定
   1. 箭头函数没有原型属性
   1. 箭头函数不能当做Generator函数，不能使用yield关键字
   > [参考：箭头函数与普通函数的区别](https://www.jianshu.com/p/73cbeb6782a0)
   
1. bind, call, apply的区别？  
   call、apply、bind的作用是改变函数运行时this的指向
   bind() 方法创建一个新的函数，在 bind() 被调用时，这个新函数的 this 被指定为 bind() 的第一个参数，而其余参数将作为新函数的参数，供调用时使用。
   ```js
    const obj = {
      x: 42,
      getX: function() {
        return this.x;
      }
    }
    
    const unboundGetX = obj.getX;
    console.log(unboundGetX()); // The function gets invoked at the global scope
    // expected output: undefined
    
    const boundGetX = unboundGetX.bind(obj);
    console.log(boundGetX());
    // expected output: 42
    ```
   call() 方法使用一个指定的 this 值和单独给出的一个或多个参数来调用一个函数。  
   bind()和call()的区别是：
   bind()会返回该函数，不会执行，而call()会执行该函数。
   ```js
    function fn(a, b, c) {
        console.log(a, b, c);
    }
    var fn1 = fn.bind(null, 'Dot');
    
    fn('A', 'B', 'C');            // A B C
    fn1('A', 'B', 'C');           // Dot A B
    fn1('B', 'C');                // Dot B C
    fn.call(null, 'Dot');      // Dot undefined undefined
    ```
   > 该方法的语法和作用与 apply() 方法类似，只有一个区别，就是 call() 方法接受的是一个参数列表，而 apply() 方法接受的是一个包含多个参数的数组。
   
1. 什么是函数柯里化?  
   柯里化，英语：Currying，是把接受多个参数的函数变换成接受一个单一参数（最初函数的第一个参数）的函数，并且返回接受余下的参数而且返回结果的新函数的技术。
   ```js
    // 正常正则验证字符串 reg.test(txt)
    
    // 函数封装后
    function check(reg, txt) {
        return reg.test(txt)
    }
    
    check(/\d+/g, 'test')       //false
    check(/[a-z]+/g, 'test')    //true
    
    // Currying后
    function curryingCheck(reg) {
        return function(txt) {
            return reg.test(txt)
        }
    }
    
    var hasNumber = curryingCheck(/\d+/g)
    var hasLetter = curryingCheck(/[a-z]+/g)
    
    hasNumber('test1')      // true
    hasNumber('testtest')   // false
    hasLetter('21212')      // false
    ```
   
1. 闭包是什么？为什么要用它？  
   `闭包`是函数和声明该函数的词法环境的组合。
   
1. 哪些操作会造成内存泄漏  
   不再用到的内存，没有及时释放，就叫做`内存泄漏`（memory leak）。
   1. 定义不使用的变量或常量会导致内存泄漏
   1. 闭包使用不当会导致内存泄漏
   
1. 原生JS中有哪些操作document的方法？  
   1. 创建新节点
      ```js
      document.createDocumentFragment() // 创建一个DOM片段
      document.createElement() // 创建一个具体的元素
      document.createTextNode() // 创建一个文本结点
      ```
   1. 添加、移除、替换、插入
      ```js
      document.appendChild() // 添加
      document.removeChild() // 移除
      document.replaceChild() // 替换
      document.insertBefore() // 插入
      ```
   1. 查找
      ```js
      document.getElementsByTagName() // 通过标签名查找
      document.getElementById() // 通过ID查找
      document.getElementsByClassName() // 通过class查找
      document.querySelector() // 通过选择器查找第一个匹配的元素
      document.querySelectorAll() // 通过选择器查找所有匹配的元素
      ```
1. 请说一下响应式数据的原理。


1. 什么是事件流？事件模型又是什么？
1. 移动端的触摸事件？事件委托是什么且什么好处？
1. 什么是 Ajax? 如何创建一个Ajax，请描述具体步骤？
1. 0.1 + 0.2 和 1.91 * 10 分别是多少？
1. 介绍Webpack的生命周期和打包的全过程？

## 综合
1. 简述同步和异步的区别  
   同步是阻塞模式，异步是非阻塞模式。  
   同步就是指一个进程在执行某个请求的时候，若该请求需要一段时间才能返回信息，那么这个进程将会一直等待下去，直到收到返回信息才继续执行下去；  
   异步是指进程不需要一直等下去，而是继续执行下面的操作，不管其他进程的状态。当有消息返回时系统会通知进程进行处理，这样可以提高执行的效率。  
   
1. 什么是渐进增强和优雅降级？
   侧重点不同，渐进增强是优先保证基本功能，向高级浏览器兼容；优雅降级是构建完整的功能，向低版本浏览器兼容。
   
1. 谈一下你对MVVM原理的理解。
   
   
1. 简述一下HTTP的原理
1. URL和URI分别是什么？URL由哪几部分构成？
1. 页面从输入url地址到页面加载显示完成，整个过程都发生了什么？
1. 介绍一下你对浏览器内核的理解？并且列举下常见的浏览器内核有哪些？  
   主要分成两部分：`渲染引擎`(layout engineer或Rendering Engine)和`JS引擎`。
     1. 渲染引擎：负责取得网页的内容（HTML、XML、图像等等）、整理讯息（例如加入CSS等），以及计算网页的显示方式，然后会输出至显示器或打印机。浏览器的内核的不同对于网页的语法解释会有不同，所以渲染的效果也不相同。所有网页浏览器、电子邮件客户端以及其它需要编辑、显示网络内容的应用程序都需要内核。
     1. JS引擎则：解析和执行Javascript来实现网页的动态效果。最开始渲染引擎和JS引擎并没有区分的很明确，后来JS引擎越来越独立，内核就倾向于只指渲染引擎。
   
   主要浏览器内核：
     1. Blink *（Chrome）*
     1. Webkit *（Safari）*
     1. Trident *（IE）*
     1. Gecko *（是由 Mozilla 工程开发出的布局引擎的名字）*
   
1. 如何解决跨域问题？

1. 栈内存和堆内存是什么？  
   - 栈内存：作用域
     1. 提供一个供JS代码自上而下执行的环境(代码都是在栈中执行的)
     2. 由于基本数据类型值比较简单,他们都是直接在栈内存中开辟个位置,把值直接存储进去的
     > 当栈内存被销毁,存储的那些基本值也都跟着销毁了
   - 堆内存：引用值对应的空间
     1. 存储弓用类型值的(对象:键值对函数:代码字符串)
     > 当前堆内存释放销毁,那么这个引用值彻底没了  
       堆内存的释放:当堆内存没有被任何的变量或者其它东西所沾用，测览器会在空闲的时候,自主的进行内存回收,把所有不被占用的堆内存销毁掉（谷歌浏览器）  
       x = null 通过空对象指针null可以让原始变量（或者其它东西）谁都不指向，那么原有占用的堆内存就没有被东西占用了，浏览器会销毁它

1. 变量的声明和定义是什么，有什么区别？  
   - `声明`(declare)： var a (默认值undefined)  
   - `定义`(defined)： a = 12 （定义就是赋值）
   
1. 变量加`var`定义和不加`var`定义有什么区别？  
   不加`var`本质是window的属性

1. 什么是变量提升？  
   当栈内存(作用域)形成，JS代码自上而下执行之前，浏览器首先会把所有带 **VAR/FUNCTION** 关键词的进行提前**声明**或者**定义**，这种预先处理机制称之为`变量提升`
   > `var`只声明未定义，`function`声明和定义都完成了

1. 如何进行网站性能优化？  
   - 减少HTTP请求
   - 减少DNS查询
   - 使用CDN
   - 避免重定向
   - 图片懒加载
   - 减少 DOM元素数量
   - 减少 DOM操作
   - 使用外部 Javascript和CSS
   - 压缩 JavaScript 、 CSS 、字体、图片等
   - 优化 CSS Sprite
   - 使用 iconfont
   - 字体裁剪
   - 多域名分发划分内容到不同域名
   - 尽量减少 iframe 使用
   - 避免图片 src 为空
   - 把样式表放在link 中
   - 把JavaScript放在页面底部
   
1. XSS/CSRF/XSRF 分别是什么  
   `XSS`：跨站脚本攻击（Cross-site scripting），攻击者可以利用这种漏洞在网站上注入恶意的客户端代码。当被攻击者登陆网站时就会自动运行这些恶意代码，从而，攻击者可以突破网站的访问权限，冒充受害者。  
   `CSRF`：跨站请求伪造（CSRF，或XSRF）是一种冒充受信任用户，向服务器发送非预期请求的攻击方式。例如，这些非预期请求可能是通过在跳转链接后的 URL 中加入恶意参数来完成:
   ```html
    <img src="https://www.example.com/index.php?action=delete&id=123">
    ```
   

## 算法
1. 二叉树有哪几种遍历方式？
1. 有哪些排序算法（冒泡排序、选择排序、计数排序、快速排序、插入排序、归并排序），说说或者实现他们的原理？

## Vue
1. Vue的生命周期有哪些？  
   beforeCreate, created, beforeMount, mounted, beforeUpdate, updated, beforeDestroy, destroyed
   
1. Vue的指令有哪些？  
   v-text, v-html, v-show, v-if, v-else, v-else-if, v-for, v-on, v-bind, v-model, v-slot, v-pre, v-cloak, v-once

1. 不使用Vuex，怎么在父子组件中相互传值？  
   `父 -> 子`： props传值  
   `子 -> 父`：$emit()事件触发父组件事件用事件方法的参数达到传值的目的

1. Vuex由哪些组成？  
   State, Getter, Mutation, Action
   
1. 路由拦截怎么做？  
   在router实例上的beforeEach()的回调函数中处理。

1. 双向绑定的原理是什么 ？
1. Axios与Ajax的区别是什么 ？


## 设计
1. GIF，JPEG，PNG三种图片的区别：
1. 如何选择应用哪种图片？
1. Canvas 和 SVG 的比较
